# 方案1

## 生成用户对于电影tag与genre的权重

建立用户与`tag`和`genre`的关系(json或者csv格式？不知道哪个性能会好一些)

用户对电影评分为`0-5`的浮点数，不过一般都是`.0`或者`.5`

去除用户小于`3`的评分，针对现在的评分数据，查找用户评分此电影的`tag`和`genre`，直接累加到用户与`tag`和`genre`的数据结构中，公式为`此电影评分×1`

对现有数据每个用户分别对`tag`和`genre`归一化处理(其实应该不用)

## 生成用户对tag和genre的优先级

建立新的用户与`tag`和`genre`优先级的结构，类似

> userId, tag_1, tag_2, tag_3... 
> userId, genre_1, genre_2, genre_3 ...
>
> tag和genre要的数量可以自己定，按推荐效果来说，应该越少越好

对上面生成好的数据每个用户对应的`tag`和`genre`权重排序然后从大到小填入其中

## 电影推荐

建立新的用户与`videoId`优先级的结构，类似

> userId, videoId_1, videoId_2, ....
>
> videoId的数量也是按照需求来定

将电影按照`voteAverage`排序，优先选取有`genre`的，然后再去选取有`tag`的(此处选取的只要存在就取到)，然后取上面videoId的数量个videoId放入结构中，若videoId不够，则仅在选取有`genre`中找，若还是不够，就在按照`voteAverage`排序中找

前端按照登陆用户的Id请求推荐的电影

# 方案2

## 数据预处理

首先对数据集进行预处理，将电影表、用户表和评分表合并为一个统一的数据表，包含用户id、电影id、评分等信息。

## 计算用户相似度

根据用户的评分行为计算用户之间的相似度。常用的相似度计算方法有余弦相似度、皮尔逊相关系数等。选择其中一种方法计算用户之间的相似度，并将结果存储在一个矩阵中。

## 找到相似用户

对于每个用户，找到与其最相似的k个用户。可以根据用户相似度矩阵来选择相似度最高的前k个用户。

## 生成推荐列表

对于每个用户，根据其相似用户的评分记录生成推荐列表。这里可以采用加权平均的方法，即将相似用户对电影的评分乘以用户间的相似度，然后将结果相加。最后将加权评分按降序排序，取前n个电影作为推荐列表。

## 输出结果

将每个用户和推荐的电影id列表存储在一个对应表中，可以将结果输出为CSV文件或其他格式。